# Root-level Dockerfile building the app from the sylius/ subdirectory
FROM php:8.2-apache

# Install required PHP extensions and tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    libzip-dev \
    libicu-dev \
    libxml2-dev \
    libfreetype6-dev \
    libjpeg62-turbo-dev \
    libpng-dev \
    libsqlite3-dev \
    sqlite3 \
    libonig-dev \
    pkg-config \
    zip \
    unzip \
    git \
    curl \
    ca-certificates \
    && docker-php-ext-configure gd --with-freetype --with-jpeg \
    && export PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH \
    && docker-php-ext-configure pdo_sqlite --with-pdo-sqlite=/usr \
    && docker-php-ext-install -j$(nproc) zip pdo pdo_sqlite intl xml gd mbstring opcache \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*
# Enable Apache mod_rewrite
RUN a2enmod rewrite

# Set working directory
WORKDIR /var/www/html

# Install Composer (must be BEFORE any 'composer' commands)
RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

# Copy composer file for caching
COPY composer.json ./

# Install deps (allow scripts for Symfony Runtime)
ENV COMPOSER_ALLOW_SUPERUSER=1
ENV APP_ENV=prod
ENV APP_DEBUG=0
ENV DATABASE_URL=sqlite:///var/www/html/var/data.db
ENV SYMFONY_ENV=prod
# Install without scripts first to avoid symfony-cmd issues
RUN composer install --no-dev --optimize-autoloader --no-scripts --no-interaction --prefer-dist --ignore-platform-reqs
# Generate autoload_runtime.php manually if it doesn't exist (Symfony Runtime requirement)
# This file is normally generated by symfony/runtime composer scripts
# Note: We'll load index.php.original (created later) to avoid circular reference
RUN cat > vendor/autoload_runtime.php << 'EOF'
<?php

// Ensure autoloader is loaded before anything else
require_once __DIR__."/autoload.php";

return function (array $context = []) {
    if (!isset($context["APP_ENV"])) {
        throw new RuntimeException("Please provide \"APP_ENV\" environment variable.");
    }
    $_SERVER["APP_ENV"] = $_ENV["APP_ENV"] = $context["APP_ENV"];
    $_SERVER["APP_DEBUG"] = $_SERVER["APP_DEBUG"] ?? $_ENV["APP_DEBUG"] ?? "prod" !== $context["APP_ENV"];
    $_SERVER["APP_DEBUG"] = $_ENV["APP_DEBUG"] = (int) $_SERVER["APP_DEBUG"] || ("prod" !== $context["APP_ENV"]);
    
    // Load index.php.original (the original Kernel factory) instead of index.php (our bootstrap)
    $indexFile = file_exists(__DIR__."/../public/index.php.original") 
        ? __DIR__."/../public/index.php.original" 
        : __DIR__."/../public/index.php";
    
    $runtime = require $indexFile;
    return $runtime($context);
};
EOF
# Verify autoload_runtime.php exists
RUN test -f vendor/autoload_runtime.php || (echo "ERROR: Failed to create autoload_runtime.php" && exit 1)

# Copy the rest of the app (vendor will persist since it's not in source)
COPY . .

# Verify vendor still exists after copy
RUN ls -la vendor/autoload_runtime.php || (echo "ERROR: vendor/autoload_runtime.php missing after COPY" && exit 1)

# Verify critical application files exist
RUN echo "=== Verifying application structure ===" && \
    ls -la /var/www/html/ | head -20 && \
    echo "=== Checking public directory ===" && \
    ls -la /var/www/html/public/ | head -20 && \
    test -d public || (echo "ERROR: public directory missing" && exit 1) && \
    test -f public/index.php || (echo "ERROR: public/index.php missing" && exit 1) && \
    test -d src || (echo "ERROR: src directory missing" && exit 1) && \
    test -d config || (echo "ERROR: config directory missing" && exit 1) && \
    echo "Application structure verified"

# Create necessary directories and set permissions
# Clear any stale cache from source - this is critical for production
RUN rm -rf var/cache var/log var/sessions || true
RUN mkdir -p var/cache/prod var/log var/sessions \
    && touch var/data.db \
    && chown -R www-data:www-data /var/www/html \
    && chmod -R 755 /var/www/html \
    && chmod -R 777 var/ \
    && chmod 666 var/data.db

# Fix Doctrine cache configuration to avoid CacheAdapter issue
# Override the prod doctrine config to use Symfony cache directly
RUN cat > config/packages/prod/doctrine.yaml << 'DOCTRINEEOF'
doctrine:
    orm:
        entity_managers:
            default:
                metadata_cache_driver:
                    type: pool
                    pool: doctrine.system_cache_pool
                query_cache_driver:
                    type: pool
                    pool: doctrine.system_cache_pool
                result_cache_driver:
                    type: pool
                    pool: doctrine.result_cache_pool

framework:
    cache:
        pools:
            doctrine.result_cache_pool:
                adapter: cache.adapter.filesystem
            doctrine.system_cache_pool:
                adapter: cache.adapter.filesystem
DOCTRINEEOF

# Configure Apache for Sylius - minimal changes
ENV APACHE_DOCUMENT_ROOT /var/www/html/public

# Update the default virtual host to use our document root (use actual path in RUN)
RUN sed -ri -e 's|DocumentRoot /var/www/html|DocumentRoot /var/www/html/public|g' /etc/apache2/sites-available/*.conf \
    && echo '<Directory /var/www/html/public>' >> /etc/apache2/apache2.conf \
    && echo '    Options Indexes FollowSymLinks' >> /etc/apache2/apache2.conf \
    && echo '    AllowOverride All' >> /etc/apache2/apache2.conf \
    && echo '    Require all granted' >> /etc/apache2/apache2.conf \
    && echo '</Directory>' >> /etc/apache2/apache2.conf

# Ensure .htaccess routing
RUN echo 'RewriteEngine On' > /var/www/html/public/.htaccess \
    && echo 'RewriteCond %{REQUEST_FILENAME} !-f' >> /var/www/html/public/.htaccess \
    && echo 'RewriteRule ^(.*)$ index.php [QSA,L]' >> /var/www/html/public/.htaccess

# Test Apache configuration before finalizing
RUN apachectl -t 2>&1 || (echo "=== Apache config test failed! ===" && cat /etc/apache2/apache2.conf | tail -30 && echo "=== End of config ===" && exit 1) && echo "Apache configuration test passed"

# Fix index.php to auto-execute when called via web (Symfony Runtime bootstrap)
# Create index.php.original with just the Kernel factory (no autoload_runtime.php require)
# since autoloader is already loaded by autoload_runtime.php
# Note: Kernel.php must be explicitly required since it's only in autoload-dev
RUN cat > /var/www/html/public/index.php.original << 'ORIGEOF'
<?php

declare(strict_types=1);

use App\Kernel;

// Autoloader is already loaded by autoload_runtime.php
// Explicitly require Kernel since it's only in autoload-dev and we're using --no-dev
require_once dirname(__DIR__).'/src/Kernel.php';

return static function (array $context) {
    return new Kernel($context['APP_ENV'], (bool) $context['APP_DEBUG']);
};
ORIGEOF

# Create a simple test file first to verify Apache works
RUN echo '<?php phpinfo(); ?>' > /var/www/html/public/test.php

# Create the bootstrap index.php
RUN cat > /var/www/html/public/index.php << 'EOF'
<?php

declare(strict_types=1);

// Prevent fatal errors from crashing Apache
register_shutdown_function(function() {
    $error = error_get_last();
    if ($error !== null && in_array($error['type'], [E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR])) {
        http_response_code(500);
        echo '<h1>Fatal Error</h1>';
        echo '<p><strong>Message:</strong> ' . htmlspecialchars($error['message']) . '</p>';
        echo '<p><strong>File:</strong> ' . htmlspecialchars($error['file']) . ':' . $error['line'] . '</p>';
        exit;
    }
});

// Enable error reporting
ini_set('display_errors', '1');
ini_set('display_startup_errors', '1');
error_reporting(E_ALL);

try {
    // Load autoloader first
    if (!file_exists(dirname(__DIR__).'/vendor/autoload.php')) {
        throw new RuntimeException('Composer autoloader not found. Run composer install.');
    }
    require_once dirname(__DIR__).'/vendor/autoload.php';

    // Load the runtime function
    if (!file_exists(dirname(__DIR__).'/vendor/autoload_runtime.php')) {
        throw new RuntimeException('autoload_runtime.php not found.');
    }
    $runtime = require dirname(__DIR__).'/vendor/autoload_runtime.php';

    $appEnv = $_ENV['APP_ENV'] ?? $_SERVER['APP_ENV'] ?? 'prod';
    $appDebug = (bool) ($_ENV['APP_DEBUG'] ?? $_SERVER['APP_DEBUG'] ?? '0');

    // The runtime function loads index.php.original and returns the Kernel
    $kernel = $runtime([
        'APP_ENV' => $appEnv,
        'APP_DEBUG' => $appDebug,
    ]);

    // Handle the request
    $request = \Symfony\Component\HttpFoundation\Request::createFromGlobals();
    $response = $kernel->handle($request);
    $response->send();
    $kernel->terminate($request, $response);
} catch (\Throwable $e) {
    // Display error details instead of crashing
    http_response_code(500);
    echo '<h1>Error</h1>';
    echo '<p><strong>Message:</strong> ' . htmlspecialchars($e->getMessage()) . '</p>';
    echo '<p><strong>File:</strong> ' . htmlspecialchars($e->getFile()) . ':' . $e->getLine() . '</p>';
    echo '<pre>' . htmlspecialchars($e->getTraceAsString()) . '</pre>';
    error_log('PHP Error: ' . $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine());
}
EOF

# Create startup script with logging
RUN echo '#!/bin/bash' > /entrypoint.sh && \
    echo 'set -e' >> /entrypoint.sh && \
    echo 'echo "=== Starting SurfsUp Shop ==="' >> /entrypoint.sh && \
    echo 'echo "Document root: ${APACHE_DOCUMENT_ROOT:-/var/www/html/public}"' >> /entrypoint.sh && \
    echo 'ls -la ${APACHE_DOCUMENT_ROOT:-/var/www/html/public} | head -10' >> /entrypoint.sh && \
    echo 'echo "Testing Apache config..."' >> /entrypoint.sh && \
    echo 'apachectl -t 2>&1' >> /entrypoint.sh && \
    echo 'echo "Starting Apache..."' >> /entrypoint.sh && \
    echo 'exec apache2-foreground' >> /entrypoint.sh && \
    chmod +x /entrypoint.sh

EXPOSE 80
CMD ["/entrypoint.sh"]


